%********************************************************************
% Appendix
%*******************************************************
% If problems with the headers: get headings in appendix etc. right
%\markboth{\spacedlowsmallcaps{Appendix}}{\spacedlowsmallcaps{Appendix}}
\chapter{Appendix: Python implementation}

\section{Engineering Python's modules}

In the rest of this document we report and comment some figures about
colourings of \emph{Riordan arrays}: we consider standard triangles and their
inverses, in the majority of case the congruence partitioning is used.

Mathematically, a function $colouring$ has been implemented. Let $\mathcal{R}$
be a Riordan array and $d_{nk} \in \mathcal{R}$ its generic element, moreover
define a set of $k$ colours $\lbrace c_0, \ldots, c_{k-1} \rbrace$, so the
function has the following type: 
\begin{displaymath} 
    colouring : \mathbb{N} \times\mathbb{N} \rightarrow \lbrace c_0, \ldots, c_{k-1} \rbrace
\end{displaymath}

The following implementations are available in our Python package:
\begin{itemize}
    \item choose a module $p$ (in most cases a prime although) and
        colour $\mathcal{R}$ associating to each remainder class 
        $r \in \lbrace[0],\ldots,[p-1]\rbrace$
        a different colour $c_r$:
        \begin{displaymath}
            colouring_{p}(n,k) = c_{r} \leftrightarrow d_{nk} \equiv_{p} r
        \end{displaymath}
    \item choose a module $p$ (in most cases a prime although) and
        \emph{bi}-colour $\mathcal{R}$ with $c_0$ if $d_{nk}$ 
        is a multiple of $p$, otherwise use a colour $c_1$:
        \begin{displaymath}
            colouring_{p}(n,k) = c_{0} \leftrightarrow p | d_{nk}
        \end{displaymath}
    \item a less used one, \emph{bi}-colour $\mathcal{R}$ with $c_0$ 
        if $d_{nk}$ is a prime, otherwise use a colour $c_1$:
        \begin{displaymath}
            colouring(n,k) = c_{0} \leftrightarrow 
                \nexists p\in\lbrace 2,\ldots,d_{nk}-1\rbrace.p|d_{nk} 
        \end{displaymath}
\end{itemize}

We choose the \emph{Python} language to implement such a function and we rest
on the \emph{Sage} \cite{sage} framework to do hard computational stuff, like
Taylor expansion of a function or solving equations \emph{symbolically}.

Our implementation aims at a subset of the \emph{Riordan group} theory, focusing
on simplicity and sound design principles. The interest of the author for the
\emph{Smalltalk} programming language has influenced the design of this code
base, with a strong focus on the concept of \emph{messaging} between objects as
the core programming paradigm. We believe that keeping such an approach,
classes are structured to be really extendible, keeping the whole
implementation limited to few core concept. In addition to this orientation, we
have integrated some particular features supplied by the Python programming
language in order to ease the experience of playing with our objects.

We wont describe all the ``nitty-gritty'' details of the implementation, on the
other hand we focus on the architecture, pointing out the concepts, and some
design principles and patterns used to implement it.

\subsection{Architecture}

Talking about \emph{an architecture} to describe the implementation of a single
\emph{functionality}, namely the $colouring$ function defined in the previous
section, seems to be wasteful. However, \emph{Smalltalkers} like to introduce a
little language for each problem they tackle, which is the same to say they
introduce \emph{an architecture}, eventually. What is important is the spirit
and the principle behind their approach: \emph{messaging}. As
\citeauthor{kay:on:messaging} states in \cite{kay:on:messaging}, what is really
important is the relation and the net of messages that a set of objects sends
to each other. Pairing this principle with the one shown in
\cite{friedman:felleisen:few:java:few:patterns}, about looking at behavior as
an object, we have a solid track to follow.

Our objects are instances of a few class hierarchies, many of which can be seen
as \emph{dispatching objects}, while actual behavior is performed on a very
restricted set of them, what we call \emph{action objects}. So, the whole
$colouring$ functionality is taken apart into a set of small hierarchy, each
one of them caught a \emph{context} that can happen in the study session, for
example the desired type of partitioning or if the representation should have a
plain layout or a centered one, and so on. All these little hierarchies doesn't
know how to do hard symbolic computation or how to generate a result
\TeX\,file, their only duty is to inform that \emph{the current functionality
should be performed under the context they represent}. This is pretty similar
to the approach advised by \emph{functional programming}, where \emph{pattern
matching} over type constructors is a compact way to express the same
computation as we do with a net of \emph{messages}.

Only a small set of \emph{action objects}, aka \emph{visitors} if we look at
them from the design patterns point of view, code the actual implementation
because only them know the \emph{entire} context. With this approach, if we
would like to implement a new \emph{functionality}, we have to \emph{create} a
new \emph{action object}; on the other hand, if we would like to augment the
context with new informations, we are required to \emph{refine} methods already
implemented in \emph{action objects}, without updating the remaining classes.


\subsection{Core classes}

\section{A \emph{Sage} study file}

In this section we show a typical session to study the \emph{Motzkin} array
$\mathcal{M}$.  First we report the complete file that we have used to generate
matrix raw expansion and a coloured representation of
$\mathcal{M}_{\equiv_{7}}$; after we take it apart describing the meaning of
each chunk of code.

\inputminted[
    mathescape,
    linenos,
    %numbersep=5pt,
    %gobble=2,
    frame=lines,
    framesep=2mm,
    breaklines
    ]{python}{../sympy/motzkin/motzkin-for-document-inclusion.sage}

Having seen the complete session file for array $\mathcal{M}$, in the
following paragraphs we take it apart, describing each little chunk.

\inputminted[
    mathescape,
    linenos,
    %numbersep=5pt,
    %gobble=2,
    frame=lines,
    framesep=2mm,
    breaklines,
    firstline=1,
    lastline=16
    ]{python}{../sympy/motzkin/motzkin-for-document-inclusion.sage}
    
In this chunk we do some boring \emph{imports} and prepare a variable
\mintinline{python}|tex_parent_prefix| in order to localize the destination
path for files that will be generated. Finally, variable \mintinline{python}|t| is
defined in order to denote a \emph{math} undeterminate variable $t$.

\inputminted[
    mathescape,
    linenos,
    %numbersep=5pt,
    %gobble=2,
    frame=lines,
    framesep=2mm,
    breaklines,
    firstline=19,
    lastline=25
    ]{python}{../sympy/motzkin/motzkin-for-document-inclusion.sage}

Here we define the desired partitioning, in this case we want
$\mathcal{M}_{\stackrel{\circ}{\equiv_{7}}}$, and the colouring object. It
keeps track of the number of rows, namely $127$; if the representation should
be centered or aligned to the left, as a raw matrix expansion; and, finally, if
negative coefficients in the inverse array $\mathcal{M}^{-1}$ should get
lighter colour variants respect ones that positive coefficient in $\mathcal{M}$
get, under congruence relation $\equiv_{7}$.

\inputminted[
    mathescape,
    linenos,
    %numbersep=5pt,
    %gobble=2,
    frame=lines,
    framesep=2mm,
    breaklines,
    firstline=32,
    lastline=45
    ]{python}{../sympy/motzkin/motzkin-for-document-inclusion.sage}

Here we define function $d$ and function $h$ of $\mathcal{M}$ and build an
object that denotes the \emph{mathematical} concept of Riordan array, 
composed of the following slots:
\begin{itemize}
    \item a \emph{subgroup}, in this case we use the \emph{plain vanilla} definition by
        providing functions $d$ and $h$ directly;
    \item a \emph{name}, which will be used to build unique filenames for 
        the generated \TeX\,files;
    \item a \emph{mathematical name}, as the ones used in this document, such as $\mathcal{M}$ and so on,
        used within \emph{captions} environments, for example;
    \item an \emph{additional text} in order to augment array's description, it will be attached
        to \emph{captions} environments again. In this text \emph{any} \LaTeX\, code can be used.
\end{itemize}

\inputminted[
    mathescape,
    linenos,
    %numbersep=5pt,
    %gobble=2,
    frame=lines,
    framesep=2mm,
    breaklines,
    firstline=48,
    lastline=56
    ]{python}{../sympy/motzkin/motzkin-for-document-inclusion.sage}

Here some computation happen actually: application of function
\mintinline{python}|colouring| does raw expansion of $\mathcal{M}$ up to row $126$ included,
starting from row 0, and write all files containing results, splitted according their content.

\inputminted[
    mathescape,
    linenos,
    %numbersep=5pt,
    %gobble=2,
    frame=lines,
    framesep=2mm,
    breaklines,
    firstline=58,
    lastline=62
    ]{python}{../sympy/motzkin/motzkin-for-document-inclusion.sage}

Here we tackle the settings for computing $\mathcal{M}^{-1}$. Mathematically,
it is necessary to compute the \emph{computational inverse} $\hat{h}$ of
function $h$ and this is the main difficult point to solve, for \emph{Sage}
\cite{sage} too.  \emph{Sage} framework is pretty powerful, for instance it can
compute function $\hat{h}_{\mathcal{P}}$ for the Pascal array $\mathcal{P}$,
but for Motzkin array things get complicated because a radical appears in
function $h$. For this, the \emph{message} \mintinline{python}|inverse| sent to
the object denoting $\mathcal{M}$ is a curious one because it allow us to
supply an \emph{help} function, which will allow \emph{Sage} to solve an
equation yielding function $\hat{h}$. Formally, to find $\hat{h}$ we could
solve a \emph{functional} equation $h(\hat{h}(t))=t$ because $h$ is known.
Otherwise, we could use the \emph{change of variable} trick yielding
$\hat{h}(y)$ if we can solve $h(t)=y$: 
\begin{displaymath}
    \left.\left[\hat{h}(y)=t\right|y=h(t)\right)
\end{displaymath}
so, at the end, we have to solve another equation respect 
variable $t$, obtaining it as a function of variable $y$.

This is exactly the aim of the helper function. It receive three arguments, 
namely variable $y$, variable $t$ and an equation over function $h$ such that:
\begin{displaymath}
    y=h(t)
\end{displaymath}
which in the case of array $\mathcal{M}$ rewrites as:
\begin{displaymath}
    y=\frac{1-t-\sqrt{1-2t-3t^{2}}}{2t}
\end{displaymath}
our help is to manipulate the equation in order to remove the radical. Therefore
we can do the following steps, in the given order:
\begin{displaymath}
    \begin{split}
        y&=\frac{1-t-\sqrt{1-2t-3t^{2}}}{2t} &\quad\text{given}\\
        2ty &=1-t-\sqrt{1-2t-3t^{2}} &\quad\text{multiply by } 2t\\
        -2ty &=-1+t+\sqrt{1-2t-3t^{2}} &\quad\text{multiply by } -1\\
        1-t-2ty &=\sqrt{1-2t-3t^{2}} &\quad\text{add } -(t-1)\\
        \left(1-t-2ty\right)^{2} &=1-2t-3t^{2} &\quad\text{square}\\
    \end{split}
\end{displaymath}
which is exactly the meaning of the supplied lambda: \mint{python}|lambda y, t,
equation: (equation*2*t*(-1) -(t-1))**2| 

\emph{Sage} is now able to solve the last equation respect variable $t$ and allow
to find the desired function $\hat{h}$ as:
\begin{displaymath}
    \left.\left[\hat{h}(y)=\frac{y}{1+y+y^{2}}\right|
        y=\frac{1-t-\sqrt{1-2t-3t^{2}}}{2t} \right]
\end{displaymath}

To be truly precise, the above \emph{helper} lambda expression is actually an
help to \emph{Sage} to build the inverse of an array, but it is also a
\emph{certificate} for the computed compositional inverse function $\hat{h}$.
Under the hood it is used also at the end of the search of $\hat{h}$ to check
if it really satisfies $\hat{h}(h(t))=t$.

\inputminted[
    mathescape,
    linenos,
    %numbersep=5pt,
    %gobble=2,
    frame=lines,
    framesep=2mm,
    breaklines,
    firstline=65,
    lastline=74
    ]{python}{../sympy/motzkin/motzkin-for-document-inclusion.sage}

Finally, as before, we do actually the computation that will raw expand
$\mathcal{M}^{-1}$ and will produce desired \LaTeX\,files composed of code
necessary to build the modular representation
$\left(\mathcal{M}^{-1}\right)_{\equiv_{7}}$.

This is the most complete example our simple implementation allow us to do but,
although simple, it generate \emph{objects of beauty}.
