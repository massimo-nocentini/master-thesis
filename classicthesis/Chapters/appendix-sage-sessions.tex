%********************************************************************
% Appendix
%*******************************************************
% If problems with the headers: get headings in appendix etc. right
%\markboth{\spacedlowsmallcaps{Appendix}}{\spacedlowsmallcaps{Appendix}}
\chapter{Appendix: Python implementation}

\section{Big picture}

In the rest of this document we report and comment some figures about
colourings of \emph{Riordan arrays}: we consider standard triangles and their
inverses, in the majority of case the congruence partitioning is used.

Mathematically, a function $colouring$ has been implemented. Let $\mathcal{R}$
be a Riordan array and $d_{nk} \in \mathcal{R}$ its generic element, moreover
define a set of $k$ colours $\lbrace c_0, \ldots, c_{k-1} \rbrace$, so the
function has the following type: 
\begin{displaymath} 
    colouring : \mathbb{N} \times\mathbb{N} \rightarrow \lbrace c_0, \ldots, c_{k-1} \rbrace
\end{displaymath}

The following implementations are available in our Python package:
\begin{itemize}
    \item choose a module $p$ (in most cases a prime although) and
        colour $\mathcal{R}$ associating to each remainder class 
        $r \in \lbrace[0],\ldots,[p-1]\rbrace$
        a different colour $c_r$:
        \begin{displaymath}
            colouring_{p}(n,k) = c_{r} \leftrightarrow d_{nk} \equiv_{p} r
        \end{displaymath}
    \item choose a module $p$ (in most cases a prime although) and
        \emph{bi}-colour $\mathcal{R}$ with $c_0$ if $d_{nk}$ 
        is a multiple of $p$, otherwise use a colour $c_1$:
        \begin{displaymath}
            colouring_{p}(n,k) = c_{0} \leftrightarrow p | d_{nk}
        \end{displaymath}
    \item a less used one, \emph{bi}-colour $\mathcal{R}$ with $c_0$ 
        if $d_{nk}$ is a prime, otherwise use a colour $c_1$:
        \begin{displaymath}
            colouring(n,k) = c_{0} \leftrightarrow 
                \nexists p\in\lbrace 2,\ldots,d_{nk}-1\rbrace.p|d_{nk} 
        \end{displaymath}
\end{itemize}

\section{Engineering Python's modules}

\section{A \emph{Sage} study file}

In this section we show a typical session to study the \emph{Motzkin} array
$\mathcal{M}$.  First we report the complete file that we have used to generate
matrix raw expansion and a coloured representation of
$\mathcal{M}_{\equiv_{p}}$, for some prime $p$; after we take it apart
describing the meaning of each chunk of code.

\inputminted[
    mathescape,
    linenos,
    %numbersep=5pt,
    %gobble=2,
    frame=lines,
    framesep=2mm,
    breaklines
    ]{python}{../sympy/motzkin/motzkin-for-document-inclusion.sage}

Having seen the complete session file for array $\mathcal{M}$, in the
following paragraphs we take it apart, describing each little chunk.

\inputminted[
    mathescape,
    linenos,
    %numbersep=5pt,
    %gobble=2,
    frame=lines,
    framesep=2mm,
    breaklines,
    firstline=1,
    lastline=16
    ]{python}{../sympy/motzkin/motzkin-for-document-inclusion.sage}
    
In this chunk we do some boring \emph{imports} and prepare a variable
\mintinline{python}|tex_parent_prefix| in order to localize the destination
path for files that will be generated. Finally, variable \mintinline{python}|t| is
defined in order to denote a \emph{math} undeterminate variable $t$.

\inputminted[
    mathescape,
    linenos,
    %numbersep=5pt,
    %gobble=2,
    frame=lines,
    framesep=2mm,
    breaklines,
    firstline=19,
    lastline=25
    ]{python}{../sympy/motzkin/motzkin-for-document-inclusion.sage}

Here we define the desired partitioning, in this case we want
$\mathcal{M}_{\stackrel{\circ}{\equiv_{7}}}$, and the colouring object. It
keeps track of the number of rows, namely $127$; if the representation should
be centered or aligned to the left, as a raw matrix expansion; and, finally, if
negative coefficients in the inverse array $\mathcal{M}^{-1}$ should get
lighter colour variants respect ones that positive coefficient in $\mathcal{M}$
get, under congruence relation $\equiv_{7}$.

\inputminted[
    mathescape,
    linenos,
    %numbersep=5pt,
    %gobble=2,
    frame=lines,
    framesep=2mm,
    breaklines,
    firstline=32,
    lastline=45
    ]{python}{../sympy/motzkin/motzkin-for-document-inclusion.sage}

Here we define function $d$ and function $h$ of $\mathcal{M}$ and build an
object that denotes the \emph{mathematical} concept of Riordan array, 
composed of the following slots:
\begin{itemize}
    \item a \emph{subgroup}, in this case we use the \emph{plain vanilla} definition by
        providing functions $d$ and $h$ directly;
    \item a \emph{name}, which will be used to build unique filenames for 
        the generated \TeX\,files;
    \item a \emph{mathematical name}, as the ones used in this document, such as $\mathcal{M}$ and so on,
        used within \emph{captions} environments, for example;
    \item an \emph{additional text} in order to augment array's description, it will be attached
        to \emph{captions} environments again. In this text \emph{any} \LaTeX\, code can be used.
\end{itemize}

\inputminted[
    mathescape,
    linenos,
    %numbersep=5pt,
    %gobble=2,
    frame=lines,
    framesep=2mm,
    breaklines,
    firstline=48,
    lastline=56
    ]{python}{../sympy/motzkin/motzkin-for-document-inclusion.sage}

Here some computation happen actually: application of function
\mintinline{python}|colouring| does raw expansion of $\mathcal{M}$ up to row $126$ included,
starting from row 0, and write all files containing results, splitted according their content.

\inputminted[
    mathescape,
    linenos,
    %numbersep=5pt,
    %gobble=2,
    frame=lines,
    framesep=2mm,
    breaklines,
    firstline=58,
    lastline=62
    ]{python}{../sympy/motzkin/motzkin-for-document-inclusion.sage}

Here we tackle the settings for computing $\mathcal{M}^{-1}$. Mathematically,
it is necessary to compute the \emph{computational inverse} $\hat{h}$ of
function $h$ and this is the main difficult point to solve, for \emph{Sage}
\cite{sage} too.  \emph{Sage} framework is pretty powerful, for instance it can
compute function $\hat{h}_{\mathcal{P}}$ for the Pascal array $\mathcal{P}$,
but for Motzkin array things get complicated because a radical appears in
function $h$. For this, the \emph{message} \mintinline{python}|inverse| sent to
the object denoting $\mathcal{M}$ is a curious one because it allow us to
supply an \emph{help} function, which will allow \emph{Sage} to solve an
equation yielding function $\hat{h}$. Formally, to find $\hat{h}$ we could
solve a \emph{functional} equation $h(\hat{h}(t))=t$ because $h$ is known.
Otherwise, we could use the \emph{change of variable} trick yielding
$\hat{h}(y)$ if we can solve $h(t)=y$. This is exactly the aim of the helper
function, it receive three arguments: variable $y$, variable $t$ and an equation
such that:
\begin{displaymath}
    y=h(t)
\end{displaymath}
which in the case of array $\mathcal{M}$ rewrites as:
\begin{displaymath}
    y=\frac{1-t-\sqrt{1-2t-3t^{2}}}{2t}
\end{displaymath}
our help is to manipulate the equation in order to remove the radical. Therefore
we can do the following steps, in the given order:
\begin{displaymath}
    \begin{split}
        y&=\frac{1-t-\sqrt{1-2t-3t^{2}}}{2t} &\quad\text{given}\\
        2ty &=1-t-\sqrt{1-2t-3t^{2}} &\quad\text{multiply by } 2t\\
        -2ty &=-1+t+\sqrt{1-2t-3t^{2}} &\quad\text{multiply by } -1\\
        1-t-2ty &=\sqrt{1-2t-3t^{2}} &\quad\text{add } -(t-1)\\
        \left(1-t-2ty\right)^{2} &=1-2t-3t^{2} &\quad\text{square}\\
    \end{split}
\end{displaymath}
which is exactly the meaning of the supplied lambda: \mint{python}|lambda y, t,
equation: (equation*2*t*(-1) -(t-1))**2| 

\emph{Sage} is now able to solve the last equation respect variable $t$ and allow
to find the desired function $\hat{h}$ as:
\begin{displaymath}
    \left.\left[\hat{h}(y)=\frac{y}{1+y+y^{2}}\right|
        y=\frac{1-t-\sqrt{1-2t-3t^{2}}}{2t} \right]
\end{displaymath}

\inputminted[
    mathescape,
    linenos,
    %numbersep=5pt,
    %gobble=2,
    frame=lines,
    framesep=2mm,
    breaklines,
    firstline=65,
    lastline=74
    ]{python}{../sympy/motzkin/motzkin-for-document-inclusion.sage}

Finally, as before, we do actually the computation that will raw expand
$\mathcal{M}^{-1}$ and will produce desired \LaTeX\,files composed of code
necessary to build the modular representation
$\left(\mathcal{M}^{-1}\right)_{\equiv_{7}}$.

This is the most complete example our simple implementation allow us to do but,
although simple, it generate \emph{objects of beauty}.
